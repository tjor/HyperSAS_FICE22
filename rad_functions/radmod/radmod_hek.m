function [IT, ID, IS] = radmod_adap(timestamp,lat,lon,realmet); %  radmod_hek%  This code is a slight variation of the Gregg&Carder adaptation of the Bird&Riordan spectral irradiance model.%  Written by:     Richard Davis, Last Modified:  1-April-98%  hek received from stsi 26-Oct-17 and editted for in water trios self shading correction (return direct and diffuse, and total irradiance)%  Load the extraterrestrial solar spectrum and atmospheric transmissivities%  Wavelength is in um%  ah2o, ao2, ao3 are the spectral absorption coefficients%    of water, gas, and ozone, repectively (cm-1)%  etr is the extraterrestrial irradiance (W m-2 um-1)%    NOTE:  integration of etr does not yield the solar constant (1367 W m-2)%           this is because etr here stops at 4 um.load inatmos.matwave=awave;clear awave%  Load the meteorological data%  If met data exists, set realmet in call to 1;%  otherwise, set realmet to 0 to allow for the creation of fake met vectors%  input%    dd = day of year for which you want met data%  output%    dectime = decimal time (days); Jan 1 = 1%    lat = decimal latitude (degrees)%    long = decimal longitude (degrees)%    psp = pyranometer readings (W m-2)%    slvp = sea-level pressure (mb)%    dryt = dry air temperature (deg C)%    relhum = relative humidity (%)%    windspd = wind speed (m s-1)%    windavg = 24hr mean wind speed (m s-1)realmet=0;if realmet==1  [dectime,lat,long,psp,slvp,dryt,relhum,windspd,windavg]=bozone_metload(dd);	else  	waitfor(met_gui2)	dectime=(startinput:byinput/1440:toinput)';	hemis=hemisinput;	lat=latinput* ones(size(dectime));	long=longinput* ones(size(dectime));	psp=Pspinput * ones(size(dectime));	slvp=slvpinput * ones(size(dectime));	dryt=Drytinput * ones(size(dectime));	relhum=relhuminput * ones(size(dectime));	windspd=windspdinput * ones(size(dectime));	windavg=windavginput * ones(size(dectime));	OZ=Ozoneinput/1000; %enter in OZ in Atm*cm (divide DU by 1000), Use 999 for the model to use it's own computation (from Van Heukleton model1979)	clear *inputend%  Set some constantsviz = 23;  %  Unlimited horizontal visibility (km)am = 1;    %  The Gregg-Carder factor set to marine%  Calculate zenith angle (deg) and earth-sun distance correction (unitless)[zenang, esd] = solstuff (lat,dectime);%  If zenith angle is >= 90 (i.e., sun hasn't risen), set it to 91 for easy indexingi=find(zenang>=90);zenang(i)=ones(size(i)) * 91;%  Calculate various air masses, ozone and precipitable water concentrations%  input%    defined above%  output%    M = relative optical air mass%    MP = pressure-corrected relative optical air mass%    MOZ = relative optical ozone mass%    MPST = pressure-corrected standard air mass%    OZ = ozone concentration (atm cm)%    precwat = precipitable water (cm)[M, MP, MOZ, MPST, OZ, precwat] = atmosph(lat,long,dectime,zenang,slvp,dryt,relhum,OZ,hemis);%  Calculate various transmissivities and reflectances%  input%    defined above%  output%    TR = atmospheric transmittance after Rayleigh scattering%    TA = aerosol transmittance%    TW = water vapor transmittance%    TO = ozone transmittance%    TU = uniformly mixed gas transmittance%    TAA = aerosol absorption%    TAS = aerosol scattering%    FS = fraction of aerosol scatter that is downward%    RGD = total direct reflectance%    RGS = total scatter reflectance%    RS = sky reflectivity[TR,TA,TW,TO,TU,TAA,TAS,FS,RGD,RGS,RS ] = ...trans(lat,long,wave,ah2o,ao3,ao2,viz,slvp,relhum,precwat,windspd,windavg,am,zenang,M,MP,MOZ,MPST,OZ);% clear M MP MOZ MPST OZ%  Calculate spectral irradiance%  input%    defined above%  output%    QT = above surface (check speclite) spectral irradiance (mole/(m^2 s um))%    IT = above surface (check speclite) spectral irradiance  (W m^-2 um^-1)[QT, IT, QD, QS, ID, IS] = ...speclite(lat,long,dectime,zenang,esd,wave,etr,ah2o,ao3,ao2,viz,slvp,relhum,precwat,windspd,windavg,am, ...         TR,TA,TW,TO,TU,TAA,TAS,FS,RGD,RGS,RS);clear QD QS%  If the sun hasn't risen, set the spectra to zero (this removes roundoff problems)         i=find(zenang==91);for j=1:length(wave)	ID(i,j)=zeros(size(i));	IS(i,j)=zeros(size(i));  IT(i,j)=zeros(size(i));  QT(i,j)=zeros(size(i));end%Transform IT to (W m^-2 nm^-1)				 IT=IT/1000;				 ID=ID/1000;				 IS=IS/1000;				 wave=wave*1000;%To save	output for mixmodel 		 s1=num2str(dectime(1));del=find(zenang~=91);ID=ID(del,1:421);IS=IS(del,1:421);IT=IS+ID;dectime=dectime(del);zenang=zenang(del);RGD=RGD(del);RGS=RGS(del);s2=num2str(round(OZ(1)*1000));if length(s2)==2; s2=['0' s2]; endif length(s2)>2; cut=length(s2)-3; s2=s2(1:length(s2)-cut);endID=ID(:,1:end);IS=IS(:,1:end);wave=wave(:,1:421);wave_par=wave(:,121:421);PAR=IT(:,121:end)*wave_par'*1e-9./(6.022e23*1e-6*6.626e-34*3e8);PARW=sum(IT(:,121:end)');% to display PAR and time for Aurea's classhours=floor(rem(dectime,1)*24);min=round((rem(dectime,1)*24-hours)*60);formatdisp(['	Hour	' 'minutes	' '	PAR (umol m^-2 s-1)'])disp([hours, min, PAR])